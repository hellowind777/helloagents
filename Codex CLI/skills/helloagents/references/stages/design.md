# 方案设计模块

本模块定义方案构思和详细规划的执行规则，在轻量迭代或标准开发模式下执行。

**核心职责:** 设计实现方案，生成方案包（proposal.md + tasks.md）。

---

## 模块入口

### 触发条件

```yaml
前置条件: 项目分析阶段完成
加载时机: 项目分析完成后自动流转
特点: 生成方案包（proposal.md + tasks.md）
```

### 状态设置

```yaml
设置时机: 本模块被加载时
设置内容:
  - CURRENT_STAGE = DESIGN
```

---

## 执行模式适配

<mode_adaptation>

### 模式行为

```yaml
读取状态变量: WORKFLOW_MODE

"交互模式"（INTERACTIVE，默认）:
  标准开发（复杂任务）: 输出方案对比 → 等待用户选择 → 详细规划 → 直接流转到开发实施阶段
  轻量迭代（简单任务）: 直接详细规划 → 直接流转到开发实施阶段

  ⚠️ 重要变更: 选择方案 = 确认执行，不再有第二次确认

"全授权模式"（AUTO_FULL，~auto命令）:
  标准开发: 静默选择推荐方案 → 详细规划 → 自动流转到开发实施阶段（不输出阶段完成状态）
  轻量迭代: 静默详细规划 → 自动流转到开发实施阶段（不输出阶段完成状态）

"规划模式"（AUTO_PLAN，~plan命令）:
  标准开发: 静默选择推荐方案 → 详细规划 → 输出整体总结 → 结束
  轻量迭代: 静默详细规划 → 输出整体总结 → 结束
```

### 阶段流转

```yaml
# ===== 关键变更: 移除冗余确认 =====
# 旧流程: 选择方案 → 确认执行 → 进入 DEVELOP
# 新流程: 选择方案 → 直接进入 DEVELOP（选择即确认）

IF WORKFLOW_MODE = INTERACTIVE:
  标准开发（复杂任务）:
    用户选择方案后:
      IF 方案包类型 = overview:
        说明: overview类型方案包不进入开发实施阶段
        处理: 直接归档（交互模式询问用户，静默模式自动归档）
        后续: 归档方案包 → 输出完成 → 状态重置
      ELSE:
        设置: CURRENT_STAGE = DEVELOP
        设置: CREATED_PACKAGE = 本次创建的方案包路径
        读取并执行: references/stages/develop.md

  轻量迭代（简单任务）:
    详细规划完成后:
      设置: CURRENT_STAGE = DEVELOP
      设置: CREATED_PACKAGE = 本次创建的方案包路径
      读取并执行: references/stages/develop.md

IF WORKFLOW_MODE = AUTO_FULL:
  静默完成详细规划
  IF 方案包类型 = overview:
    说明: overview类型方案包不进入开发实施阶段
    执行: 自动归档方案包
    后续: 在总结中标注"已归档overview方案包" → 状态重置
  ELSE:
    设置: CURRENT_STAGE = DEVELOP
    设置: CREATED_PACKAGE = 本次创建的方案包路径
    读取并执行: references/stages/develop.md

IF WORKFLOW_MODE = AUTO_PLAN:
  完成详细规划
  设置: CREATED_PACKAGE = 本次创建的方案包路径
  说明: 方案设计完成后，控制权返回 plan.md 执行流程级验收
  注意: 本阶段不直接进入开发实施阶段，由命令模块决定流程终止
  后续: 输出规划命令完成结果 → 状态重置 → 流程终止
```

### 推荐方案自动选择（静默模式）

```yaml
选择策略:
  1. 评估所有方案的风险和收益
  2. 优先选择标记为"推荐"的方案
  3. 无明确推荐时，选择风险最低的方案

记录: 在方案包的 proposal.md 中记录选择理由
```

</mode_adaptation>

---

## 执行流程

### 步骤1: 模式分支判定

> 模式条件与升级规则见 G5

```yaml
轻量迭代:
  特点: 跳过多方案对比，直接确定方案
  流程: 跳过步骤2-4 → 直接进入步骤5（详细规划）
  子代理: 调用 designer 执行单方案设计（按需调用）

标准开发:
  特点: 复杂任务需要多方案对比
  流程: 完整执行步骤2-7
  子代理: 必须调用多个 analyzer 并行分析（强制调用）
```

### 步骤2: 准备工作

**2.1 知识库检查与读取**

```yaml
知识库检查: 使用 analyze.md 已设置的 KB_SKIPPED 值（按 G1 "KB_SKIPPED 变量生命周期" 传递）
项目上下文获取:
  - KB_SKIPPED = false: 从知识库读取（INDEX.md, context.md, modules/）
  - KB_SKIPPED = true: 直接扫描代码库
```

**2.2 项目规模判定**

> 📌 规则引用: 按 G9 "大型项目判定" 条件执行，影响任务拆分粒度、文档创建策略、处理批次大小。

### 步骤3: 分析判定

**3.1 项目场景判定**

```yaml
项目场景:
  新项目:
    特征: 新项目初始化、从零开始、空目录
    执行原则:
      - 大胆创意，展现创造力
      - 包含产品视角分析（用户画像、场景、痛点、价值主张）
      - 范围模糊时主动补充合理功能
    填充深度: 完整填充（所有章节都填写）

  现有项目:
    特征: 在已有项目中修改、优化、修复
    执行原则:
      - 精准执行，尊重现有代码
      - 产品视角分析（仅当涉及用户交互时）
      - 考虑废代码处理、历史兼容性
    填充深度: 精简填充（必填章节 + 涉及的可选章节）

判断原则:
  - 根据用户需求决定交付内容的详细程度和复杂度
  - 范围模糊时: 高价值创意
  - 范围明确时: 精准高效
```

**3.2 方案类型判定**

<plan_type_rules>

按 G6 "方案包类型" 判定逻辑执行（包括 overview 类型的特殊处理）。

</plan_type_rules>

**3.3 任务复杂度判定**

```yaml
满足任一条件为复杂任务（标准开发）:
  - 新项目初始化或重大功能重构
  - 涉及架构决策或技术选型
  - 存在多种实现路径
  - 涉及多个模块(>1)或影响文件数>3
  - 用户明确要求多方案
```

### 步骤4: 方案构思与评估（仅标准开发/复杂任务）

> 📌 规则引用: 子代理调用按 G9 "子代理编排 - DESIGN" + G10 "跨CLI兼容规则" 执行

**方案评估标准:** 优点、缺点、性能影响、可维护性、实现复杂度、风险评估（含EHRB）、成本估算、是否符合最佳实践

```yaml
标准开发（强制方案对比）:
  - 生成 2-3 个可行方案
  - 详细评估每个方案（必须通过子代理）
  - 确定推荐方案和理由（推荐方案标题后加"推荐"标识）
  - 交互模式: 输出方案对比，询问用户选择
  - 静默模式: 选择推荐方案（不输出对比）

轻量迭代:
  - 直接确定唯一可行方案
  - 可调用 designer 子代理（按需）
  - 简要说明方案

方案选择后流转:
  交互模式:
    - 用户选择有效序号(1-N) → 直接进入步骤5（选择即确认执行）
    - 用户拒绝所有方案 → 按G3场景内容规则（确认场景）输出
      用户选择处理:
        重新构思: 返回步骤4重新构思
        取消: 按 G6 状态重置协议执行
  静默模式:
    - 选择推荐方案 → 立即进入步骤5
```

### 步骤5: 详细规划

> 脚本路径、存在性检查、错误恢复规则见 references/rules/tools.md

**脚本调用:**
```yaml
创建方案包: create_package.py <feature> [--type <implementation|overview>]
项目规模统计（可选）: project_stats.py
```

**目录/文件创建:** 按 G1 "目录/文件自动创建规则" 执行。

**脚本执行报告处理:**

```yaml
解析 create_package.py 输出:
  success=true:
    - 继续执行后续填充步骤
    - 从 context.package_path 获取方案包路径

  success=false:
    - 执行: 按 references/rules/tools.md "脚本执行报告机制 - AI降级接手流程" 处理
    - 步骤1: 质量检查 completed 列表中已完成的步骤
    - 步骤2: 发现问题则修复
    - 步骤3: 按 pending 列表继续完成（参考 templates.md "AI接手时的文件创建指南"）
    - 步骤4: 设置 CREATED_PACKAGE 为方案包路径
```

**填充步骤:**
1. 调用 create_package.py 创建方案包目录和模板文件
2. 处理执行报告（按上述规则）
3. 根据填充深度填充 proposal.md 内容
4. 填充 tasks.md 内容（任务清单，按新格式规范）
5. 设置 CREATED_PACKAGE 变量

**tasks.md 格式要求（见 attention.md 进度快照规范）:**
- 必须包含元数据头部（feature, created, status）
- 任务状态使用标准符号（[ ] → [√] / [X] / [-]）
- 便于进度快照提取和状态跟踪

### 步骤6: 方案包验收

> 按 G8 阶段验收标准（plan）执行
> 脚本路径、存在性检查、错误恢复规则见 references/rules/tools.md

```yaml
步骤:
  1. 调用 validate_package.py ${CREATED_PACKAGE}
  2. 检查验收结果

验收项:
  - 方案包结构完整 (阻断性): proposal.md + tasks.md 存在且非空
  - 方案包格式正确 (阻断性): 目录命名、文件格式符合规范
  - 任务清单可执行 (警告性): tasks.md 包含具体可执行任务
  - tasks.md 格式规范 (警告性): 包含元数据头部

验收失败处理:
  "交互模式"（INTERACTIVE）:
    - 输出验证失败详情
    - 按G3场景内容规则（警告场景）输出
    - 提示用户修复或调整

  "全授权模式"/"规划模式"（AUTO_FULL/AUTO_PLAN）:
    阻断性失败:
      - 打破静默
      - 按G3场景内容规则（警告场景）输出验证失败详情
      - 等待用户决策（修复/强制继续/终止）
    警告性失败:
      - 记录到验收报告
      - 继续执行
```

### 步骤7: 输出与流转

```yaml
输出: 按"执行模式适配 - 阶段流转"规则执行

遗留方案包扫描（AUTO_PLAN模式流程结束时）:
  执行规则: 按 G6 "遗留方案包扫描" 执行
  扫描时机: 方案设计完成、流程即将结束时
  显示条件: 检测到≥1个遗留方案包
  详细规则: 参考 references/services/package.md "遗留方案包处理"
```

---

## 用户选择处理

> 本章节定义方案设计阶段需要用户确认的场景，供 G3 输出格式统一提取。

### 场景: 方案选择（标准开发/复杂任务）

```yaml
内容要素:
  项目分析摘要: 当前项目状态和目标（1-2句）

  方案列表（必须完整输出所有方案，禁止省略）:
    每个方案包含:
      - 方案名称: 简洁的技术路径命名
      - 做法: 实现方式简述（1-2句）
      - 优点: 主要优势（1-2点）
      - 缺点: 主要劣势或风险（1-2点）

    方案数量: 2-3个
    推荐标记: 在推荐方案名称后标注"(推荐)"

  选项列表: 列出所有方案供用户选择

强制规则:
  - 所有方案的详情必须完整输出后，才能输出选项列表
  - 禁止: 只输出部分方案详情就跳到选项列表
  - 禁止: 省略任何方案的做法/优点/缺点字段

选项:
  选择方案N: 选择对应序号的方案，直接进入开发实施阶段（选择即确认）
  重新构思: 返回方案构思，重新设计方案
  取消: 按 G6 状态重置协议执行

⚠️ 重要: 选择方案后直接进入开发实施阶段，不再有第二次确认
```

### 场景: 方案包验收失败

```yaml
内容要素:
  - 验收结果: 失败项列表（阻断性/警告性）
  - 问题详情: 各失败项的具体问题描述
  - 修复建议: 针对各问题的修复建议

选项:
  修复: 根据建议修复方案包内容，重新验收
  强制继续: 忽略警告继续执行（仅警告性失败时可用）
  终止: 按 G6 状态重置协议执行
```
