# 方案设计模块

本模块定义方案构思和详细规划的执行规则，在 R2 简化流程或 R3 标准流程下执行。

**核心职责:** 收集项目上下文（Phase1）+ 设计实现方案（Phase2），生成方案包（proposal.md + tasks.md）。

---

## 模块入口

```yaml
前置: EVALUATE 阶段完成（评估确认：评分≥7 或 R2 已确认）
设置: CURRENT_STAGE = DESIGN
```

---

## 执行模式适配

按 G5 执行模式行为规范，本阶段补充规则:

### 模式行为

| 模式 | R3 标准流程 | R2 简化流程 |
|------|----------|----------|
| INTERACTIVE | 输出方案对比→用户选择→详细规划→进入 DEVELOP | Phase1+Phase2(跳过多方案对比)→进入 DEVELOP |
| DELEGATED | 推荐方案作为选择→详细规划→进入 DEVELOP | Phase1+Phase2(跳过多方案对比)→进入 DEVELOP |
| DELEGATED_PLAN | 推荐方案作为选择→详细规划→验收→结束 | Phase1+Phase2(跳过多方案对比)→验收→结束 |

⚠️ 选择方案 = 确认执行，不再有第二次确认

### 阶段切换

```yaml
方案确定后:
  overview 类型:
    INTERACTIVE → 询问归档 → 归档 → 输出完成 → 状态重置
    DELEGATED → 直接归档，总结中标注
  implementation 类型:
    设置 CREATED_PACKAGE = 方案包路径
    DELEGATED_PLAN → 返回 plan.md 执行验收
    其他 → CURRENT_STAGE = DEVELOP → 按 G7 加载开发实施阶段文件 → 进入 DEVELOP
```

### 推荐方案选择（DELEGATED模式）

```yaml
策略: 综合评估维度 → 优先"推荐"标记方案 → 无推荐则选用户价值与风险综合最优
记录: 在 proposal.md 中记录选择理由
```

---

## 执行流程

### Phase1: 上下文收集

> 按需加载: 按 G7 按需读取表"DESIGN Phase1 按需"行，根据条件加载所需文件

> 核心职责: 纯信息收集，不做设计决策。为 Phase2（方案构思）提供完整、准确的项目上下文。

#### 步骤1: 知识库开关检查

```yaml
KB_CREATE_MODE=0 → KB_SKIPPED=true
KB_CREATE_MODE=1/2/3 → KB_SKIPPED=false
传递: Phase2 及 DEVELOP 阶段直接使用此值
```

#### 步骤2: 检查知识库状态

```yaml
前置: KB_SKIPPED=false 时执行

知识库状态显示:
  KB_CREATE_MODE=0: "⚠️ 已跳过（开关关闭）"
  存在: "✅ 已加载"
  MODE=1 不存在: "ℹ️ 不存在，已跳过（建议 ~init）"
  MODE=2 不存在: 编程任务→"🔄 已自动创建" | 非编程→同MODE=1
  MODE=3 不存在: "🔄 已自动创建"

MODE=1不存在 或 MODE=2非编程不存在:
  KB_SKIPPED=true
  继续执行
```

#### 步骤3: 初步复杂度评估

```yaml
评估: 按 G9 复杂度判定标准，基于已知信息初步设置 TASK_COMPLEXITY = simple | moderate | complex
依据: 需求描述中的文件数/模块数/跨层级等维度（精确值待步骤5后确认）
脚本（可选）: project_stats.py

检测到 complex:
  输出: ℹ️ 复杂度: complex，已启用子代理编排
  继续执行
```

#### 步骤4: 获取项目上下文

```yaml
KB_SKIPPED=true → 扫描代码库
KB_SKIPPED=false → 知识库优先，不足则扫描代码库

子代理调用（按步骤3 TASK_COMPLEXITY）:
  moderate/complex + 现有代码库 → 调度原生子代理执行代码库扫描（强制）[→ G10 调用通道]
    编排: 按模块目录拆分，每个子代理负责扫描一个目录（子代理数=目录数，≤6/批）
    每个子代理 prompt 明确: 负责的目录路径 + 扫描内容（文件结构/入口点/导出接口/依赖关系）
    主代理汇总各子代理结果，合并为完整项目上下文
  moderate/complex + 新建项目(目录为空或仅配置文件) → 主代理直接执行（无代码可探索）
  simple → 主代理直接执行
```

#### 步骤5: 提取关键目标与成功标准

```yaml
从完整需求提炼核心目标，明确可验证的成功标准
```

#### 步骤6: 技术分析与准备

```yaml
执行: 定位相关模块 + 针对当前任务涉及的模块进行质量检查(过时信息/安全风险/代码异味) + 问题诊断(日志/错误)
外部工具: 需要最新技术文档时按 G4 规则调用，保存/恢复 CURRENT_STAGE
输出物: 项目上下文（技术栈、模块结构、质量问题、技术约束）

子代理调用:
  complex+依赖>5模块 → 调度原生子代理执行深度依赖分析和质量评估（强制）[→ G10 调用通道]
    编排: 按涉及模块拆分，每个子代理负责分析一个模块（子代理数=模块数，≤6/批）
    每个子代理 prompt 明确: 负责的模块路径 + 分析内容（依赖关系/API接口/质量问题/安全风险）
    主代理汇总各子代理结果，合并为完整技术分析报告
  其他 → 主代理直接执行

并行优化: 当 complex+依赖>5 且步骤4和步骤6均需调用原生子代理时:
  - 步骤6分析维度与步骤4无交集 → 并行调度 [→ G10 并行调度规则]
  - 否则 → 保持串行（步骤4先完成，结果传给步骤6）

复杂度确认: 根据完整分析结果修正 TASK_COMPLEXITY（若与步骤3初评不同则更新）

**DO NOT:** 做技术选型决策（留给 Phase2），设计实现方案（留给 Phase2），修改代码（留给 DEVELOP）
```

#### Phase1 完成

```yaml
输出: 上下文收集摘要（KB状态、复杂度、关键目标、技术约束）
继续: 直接进入方案构思与规划
```

### Phase2: 方案构思与规划

> 按需加载: 按 G7 按需读取表"DESIGN Phase2 按需"行加载所需文件

#### 步骤7: 模式分支判定

| 模式 | 特点 | 流程 | 子代理（概述，实际调用见各步骤） |
|------|------|------|--------|
| R2 简化流程 | 跳过多方案对比 | → 步骤11 | [RLM:pkg_keeper] 填充方案包（步骤11）强制 |
| R3 标准流程 | 复杂任务多方案对比 | → 步骤8-13 | 原生子代理构思方案（步骤10）+ [RLM:synthesizer] 综合（步骤10, complex时）+ [RLM:pkg_keeper] 填充（步骤11） |

#### 步骤8: 准备工作

```yaml
知识库检查: 使用 Phase1 已设置的 KB_SKIPPED 值
上下文获取: KB_SKIPPED=false→知识库读取 | KB_SKIPPED=true→扫描代码库
项目规模判定: 使用 Phase1 已设置的 TASK_COMPLEXITY，影响任务拆分粒度
```

#### 步骤9: 分析判定

**项目场景判定:**

| 场景 | 特征 | 原则 | 填充深度 |
|------|------|------|----------|
| 新项目 | 初始化/从零开始 | 大胆创意，含产品视角分析 | 完整填充 |
| 现有项目 | 修改/优化/修复 | 精准执行，尊重现有代码 | 精简填充 |

**R3 标准流程 = 多方案对比（强制，无例外）:**
R3 任务的典型特征（已在 G4 路由阶段判定，此处不再二次判定）:
- 新项目初始化/重大重构
- 架构决策/技术选型
- 多种实现路径
- 涉及>1模块或>3文件
- 用户明确要求多方案

#### 步骤10: 方案构思与评估（仅 R3 标准流程）

⚠️ **串行强制:** 步骤10 内部的"构思→评估→综合"可并行，但步骤10 整体与步骤11 之间串行:
步骤10: 原生子代理(各自独立构思方案，并行) → 主代理评估对比+标记推荐 → [RLM:synthesizer](综合, complex时)
步骤11: [RLM:pkg_keeper](填充)
步骤10 与步骤11 之间有用户选择（INTERACTIVE）或自动选择（DELEGATED），各段内部逐个调用等待返回后再发下一个

```yaml
R3 标准流程（CRITICAL）:
  方案构思: 调度 3~6 个原生子代理（按需求复杂度决定数量），每个子代理独立构思一个差异化方案（并行）[→ G10 调用通道]
    - 每个子代理接收相同的 Phase1 上下文，独立输出方案（名称、核心思路、技术路径、用户价值、优缺点）
    - 子代理之间不共享中间结果，确保方案差异化
  方案评估: 所有子代理返回后，主代理统一评估对比 → 为最优方案标记"推荐"（按 G3 推荐标记原则）
    评估维度: 用户价值（实用性/体验/现代使用场景）、技术合理性（性能/可维护性/可扩展性/生态成熟度）、风险(含EHRB)、实施成本（复杂度/工作量）
    权重: 按项目上下文动态调整（如性能关键系统提升技术合理性权重，原型/MVP 提升实施成本权重），用户价值始终不低于其他单项
    complex+评估维度≥3 → [RLM:synthesizer] 综合评估结果（强制）[→ G10 调用通道]
    其他 → 主代理直接综合
  INTERACTIVE → 输出方案对比 → ⛔ END_TURN（等待用户选择方案N / 重新构思 / 取消(→状态重置)）
    用户选择后:
      方案N → 确认选择，进入步骤11
      重新构思 → 回到步骤10 重新调度子代理构思方案（最多重试 1 次，仍不满意则取消）
      取消 → 状态重置
  DELEGATED → 推荐方案直接进入步骤11

R2 简化流程: 直接确定唯一方案 → 步骤11
```

**INTERACTIVE 输出要素（按 G3 格式包装，场景=确认 ❓）:**
```yaml
主体内容:
  上下文收集摘要（技术栈、模块结构、关键目标、技术约束）
  （空行）
  方案对比（每个方案用 - 标记，非数字编号：名称、核心思路、优缺点、推荐标记）
  （空行）
选项:
  选项：
  1~N. 各方案名称（最优方案标记推荐），N = 实际方案数
  N+1. 重新构思
  N+2. 取消
下一步引导: 引导用户回复选项编号，说明确认后进入详细规划并开始开发实施
```

**DO:** 所有方案详情完整输出后才提供选择

**DO NOT:** 在方案详情输出前提供选项；由主代理直接生成多个方案（必须通过原生子代理并行构思，每个子代理独立输出一个方案）

#### 步骤11: 详细规划

```yaml
脚本: create_package.py <feature> [--type <implementation|overview>]
目录创建: 按 G1 写入策略自动创建

脚本返回 success=false → 按 rules/tools.md AI降级接手流程处理

填充步骤:
  1. create_package.py 创建目录和模板
  2. 处理执行报告
  3. [RLM:pkg_keeper] 填充 proposal.md（按场景深度）和 tasks.md（元数据头部+任务清单+状态符号+依赖声明）（通过 PackageService 调用）[→ G10 调用通道]
     tasks.md 依赖声明: 每个任务项追加 depends_on 字段，声明前置依赖的任务编号 [→ G10 DAG 依赖调度]
     格式: [ ] 1.1 任务描述 | depends_on: [] 或 [ ] 1.2 任务描述 | depends_on: [1.1]
  4. 设置 CREATED_PACKAGE
```

#### 步骤12: 方案包验收

```yaml
脚本: validate_package.py ${CREATED_PACKAGE}

验收项:
  ⛔ 阻断性: 结构完整(proposal.md+tasks.md 存在非空)，格式正确
  ⚠️ 警告性: 任务清单可执行，tasks.md 含元数据头部

失败处理:
  INTERACTIVE → 输出: 警告（验证详情）→ ⛔ END_TURN（修复/强制继续/取消）
  DELEGATED:
    阻断性 → 中断委托 → ⛔ END_TURN（修复后重试/强制继续/取消(→状态重置)）
    警告性 → 记录继续
```

#### 步骤13: 输出与后续

```yaml
输出: 按执行模式适配规则
遗留方案包扫描: DELEGATED_PLAN 流程结束时执行
```
